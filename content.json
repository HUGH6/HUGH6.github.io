{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"[1] ES6 let与const用法总结","text":"本文主要记录ES6与旧规范相比存在的不同。相较于ES5，ES6新增了let命令和const命令来声明变量与常量，用于代替原本的var命令，以此避免var所带来的弊端。 let命令es6新增了let命令，用于声明变量，声明的变量只在let命令所在的代码块内有效。 不存在变量提升 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。 不允许重复声明 块级作用域es5只用全局作用作用域和函数作用域，没有块级作用域，这带来了很多不合理的场景。 const命令基本用法 const声明一个只读的常量，一旦声明，常量的值就不能改变。同时也意味着，const一旦声明变量，就必须立即初始化，不能等到以后赋值。 const的作用域与let相同，也不提升，同样存在暂时性死区。 本质 const实际保证的并不是变量的值不能改动，而是变量指向的那个内存地址的数据不得改动。 顶层对象的属性顶层对象 在浏览器环境指window对象，在node环境指global对象，顶层对象的属性与全局变量是等价的。 从es6开始，全局变量将逐步与顶层对象的属性脱钩。","link":"/2019/201910010101/"},{"title":"JDK源码 Object类","text":"Obejct类是所有其他类的父类，所有的对象，包括数组对象，都实现了该类的方法，它提供了以下11个方法： public final native Class&lt;?&gt; getClass() public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException protected void finalize() throws Throwable { } 源码分析getClass()native方法，final修饰，子类不可重写。 函数功能： 返回当前运行时对象的Class对象（注意：是运行时，例如，下面代码中n是Number类型的实例，但java中数值默认是Integer类型的，所以getClass返回的是Integer）。 1234\"str\".getClass() // class java.lang.String\"str\".getClass == String.class // trueNumber n = 0;Class&lt;? extends Number&gt; c = n.getClass(); // class java.lang.Integer hashCode()native方法，返回对象的哈希码，主要用于HashMap等数据结构。 哈希码的通用阅读如下： 在java程序执行过程中，在一个对象没有被改变的前提下，无论这个对象被调用多少次，hashCode方法都会返回相同的整数值。 对象的哈希码没有必要在不同的程序中保持相同的值。 如果2个对象使用equals方法进行比较并且相同的话，那么这2个对象的hashCode方法的值也必须相等。 如果根据equals方法，得到两个对象不相等，那么这2个对象的hashCode值不需要必须不相同。但是，不相等的对象的hashCode值不同的话可以提高哈希表的性能。 注意：如果2个对象的equals方法相等，那么他们的hashCode值也必须相等，反之，如果2个对象hashCode值相等，但是equals不相等，这样会影响性能，所以还是建议2个方法都一起重写。 equals()比较两个对象是否相等。Object类的默认实现是比较2个对象的内存地址是否相等： 123public boolean equals(Object obj) { return (this == obj);} 注意：如果重写了equals方法，通常有必要重写hashCode方法，这点已经在hashCode方法中说明了。 clone()native方法，创建并返回当前对象的一份拷贝。 一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 也为true。 由于Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。 toString()Object对象的默认实现，即输出类的名字@实例的哈希码的16进制： 123public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode());} notify()native方法，final修饰，不允许子类重写。 唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果所有的线程都在此对象上等待，那么只会选择一个线程，选择是任意性的。 直到当前线程放弃对象上的锁之后，被唤醒的线程才可以继续处理。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。 notify方法只能被作为此对象监视器的所有者的线程来调用。一个线程要想成为对象监视器的所有者，可以使用以下3种方法： 执行对象的同步实例方法 使用synchronized内置锁 对于Class类型的对象，执行同步静态方法 一次只能有一个线程拥有对象的监视器。 如果当前线程不是此对象监视器的所有者的话会抛出IllegalMonitorStateException异常 注意点： 因为notify只能在拥有对象监视器的所有者线程中调用，否则会抛出IllegalMonitorStateException异常 notifyAll()跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 同样，如果当前线程不是对象监视器的所有者，那么调用notifyAll同样会发生IllegalMonitorStateException异常。 wait(long timeout) throws InterruptedExceptionnative方法，final修饰，子类不可重写。 wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。 跟notify和notifyAll方法一样，当前线程必须是此对象的监视器所有者，否则还是会发生IllegalMonitorStateException异常。 wait方法会让当前线程(我们先叫做线程T)将其自身放置在对象的等待集中，并且放弃该对象上的所有同步要求。出于线程调度目的，线程T是不可用并处于休眠状态，直到发生以下四件事中的任意一件： 其他某个线程调用此对象的notify方法，并且线程T碰巧被任选为被唤醒的线程 其他某个线程调用此对象的notifyAll方法 其他某个线程调用Thread.interrupt方法中断线程T 时间到了参数设置的超时时间。如果timeout参数为0，则不会超时，会一直进行等待 所以可以理解wait方法相当于放弃了当前线程对对象监视器的所有者(也就是说释放了对象的锁)。之后，线程T会被等待集中被移除，并且重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用wait方法时的情况。然后，线程T从wait方法的调用中返回。所以，从wait方法返回时，该对象和线程T的同步状态与调用wait方法时的情况完全相同。 wait(long timeout, int nanos) throws InterruptedException同wait(long timeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。 wait() throws InterruptedException该方法一直等待，没有超时时间这个概念。 finalize()finalize方法是一个protected方法，Object类的默认实现是不进行任何操作。 该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。","link":"/2020/202006051524/"},{"title":"JDK源码 String类","text":"Java中使用String类来表示字符串，每一个字符串都是String类的实例。因为String类是被final关键词修饰的，所以实际上字符串都是常量，它们的值在创建之后不能更改，所以可以共享，并且是线程安全的。 源码分析类定义String类被声明为final，所以String类不能被继承。实现了三个接口：Serializable、Comparable 和 CharSequence。 主要字段value 一个字符数组，被声明为final，是一个不可变数组，字符串实际上就是由这样一个字符数组的形式存储。 1private final char value[]; hash 存储的是String实例的hash值，但是只有第一次调用hashCode()方法会计算hash值，然后会缓存下hash值，下次可以直接调用，初始时是0。 1private int hash; // Default to 0 构造方法String构造方法有很多，挑选部分分析。string() 直接给成员变量赋值完成。 123public String() { this.value = \"\".value;} string(String original) 直接给成员变量赋值完成。 1234public String(String original) { this.value = original.value; this.hash = original.hash;} String(char value[]) 传入的参数是一个字节数组，在赋值给value的时候不是直接赋值，而是重新复制一个数组，将新数组赋值给value，避免外部通过那个数组引用修改String内部的value。 123public String(char value[]) { this.value = Arrays.copyOf(value, value.length);} *String(StringBuffer buffer) * 这个类型的实例实际上表示的是可变字符串，内部存储也是通过字节数组来存储字符串信息，所以是直接讲传入的可变字符串内部的字符数组复制后，赋值给给value。 12345public String(StringBuffer buffer) { synchronized(buffer) { this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); }} String(StringBuilder builder) 这个类型的实例实际上表示的是可变字符串，内部存储也是通过字节数组来存储字符串信息，所以是直接讲传入的可变字符串内部的字符数组复制后，赋值给给value。 123public String(StringBuilder builder) { this.value = Arrays.copyOf(builder.getValue(), builder.length());} 主要方法length() 返回字符串的长度，实际上就是内部字符数组的长度。 123public int length() { return value.length;} isEmpty() 判断字符串是否为空，实际上就是判断内部字符数组长度是否为0。 123public boolean isEmpty() { return value.length == 0;} charAt(int index) 寻找指定索引处的字符，会首先判断是否越界，如果没有越界就返回内部字符数组对应索引的字符。 123456public char charAt(int index) { if ((index &lt; 0) || (index &gt;= value.length)) { throw new StringIndexOutOfBoundsException(index); } return value[index];} equals(Object anObject) 通过字方法来判断两个字符串是否相等。具体流程如下： 判断对象引用是否相等，如果想等直接返回true。 判断要比较的对象是否是String类型的实例，如果是，继续进行比较。 判断待比较的字符串长度是否和本字符串一致，如果一致就继续比较。 循环遍历两个字符串的内部的字符数组的每一个字符是否相等（没有做大小写转换，大小写不同则视为不相同）。 123456789101112131415161718192021public boolean equals(Object anObject) { if (this == anObject) {//1 return true; } if (anObject instanceof String) {//2 String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) {//3 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) {//4 if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} hashCode() 计算hash值。具体流程如下： 判断hash的值是否为0，如果为0，说明还没有初始化，同时判断value的长度是否大于零，如果不大于，说明次字符串时空字符串，默认hash值为0，不需要再做哈希运算。 遍历字符数组，运算公式是h = 31 * h + val[i]，有两个好处：第一，字符串靠前的字符运算出来的hash值比重更大，如果是对字符串做hash运算，前缀相近的能更大几率哈希到比较近的位置，能够聚集前缀相似的数据（局部性原理）；第二，选择的31是素数，能更好的离散数据（为什么是31而不是其他素数我也不太明白，不过31的二进制表示每一位都为1）。 123456789101112public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) {//1 char val[] = value; for (int i = 0; i &lt; value.length; i++) {//2 h = 31 * h + val[i]; } hash = h; } return h;} intern() native方法，可以将字符串对象进行手工加入常量池，如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。 compareTo(String anotherString) 比较两个字符串的的大小。具体流程如下： 获得两个字符串中较短的那个字符串的长度，赋值给lim。 循环遍历两个字符串内部的字节数组，直到遍历到第lim，比较字符是否相等，如果不相等就返回两字符之差(c1-c2)，如果都相等就返回两字符串长度之差，只有两个字符串完全相等时，才会返回0。 123456789101112131415161718public int compareTo(String anotherString) { int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2);//1 char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) {//2 char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) { return c1 - c2; } k++; } return len1 - len2;} 创建字符串两种方式的区别赋值创建直接赋值方式创建对象是在方法区的常量池。 1String str = \"hello\"; 通过构造方法创建通过构造方法创建字符串对象是在堆内存。 1String str = new String(\"hello\");//实例化的方式 两种方式的比较直接赋值 如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象“Lance”放入对象池，每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象，这样，所有直接赋值的String对象，如果利用相同的“Lance”，则String对象==返回true。只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。 构造方法 会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern()方法进行手工入池。在开发的过程中不会采用构造方法进行字符串的实例化。 12345678910111213141516public static void main(String[] args) { String str1 = \"Lance\"; String str2 = new String(\"Lance\"); String str3 = str2; //引用传递，str3直接指向st2的堆内存地址 String str4 = \"Lance\"; /** * ==: * 基本数据类型：比较的是基本数据类型的值是否相同 * 引用数据类型：比较的是引用数据类型的地址值是否相同 * 所以在这里的话：String类对象==比较，比较的是地址，而不是内容 */ System.out.println(str1==str2);//false System.out.println(str1==str3);//false System.out.println(str3==str2);//true System.out.println(str1==str4);//true} String的不可变性String被final修饰，是个常量，从一出生就注定不可变。但是为什么String要使用final修饰呢？ 123456789public static void main(String[] args) { String a = \"abc\"; String b = \"abc\"; String c = new String(\"abc\"); System.out.println(a==b); //true System.out.println(a.equals(b)); //true System.out.println(a==c); //false System.out.println(a.equals(c)); //true} 因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式，每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法仅仅适合于通过=符号进行的初始化。 需要说明一点的是，在object中，equals()是用来比较内存地址的，但是String重写了equals()方法，用来比较内容的，即使是不同地址，只要内容一致，也会返回true，这也就是为什么a.equals(c)返回true的原因了。 String不可变的好处 可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。 当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。 字符串常量池常量池表（Constant_Pool table） class文件中存储所有常量（包括字符串）的table。这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。 运行时常量池（Runtime Constant Pool） JVM内存中方法区的一部分，这是运行时的内容。这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个class对应一个运行时常量池。上一句中说绝大部分是因为：除了 class中常量池内容，还可能包括动态生成并加入这里的内容。 字符串常量池（String Pool） 这部分也在方法区中，但与Runtime Constant Pool不是一个概念，String Pool是JVM实例全局共享的，全局只有一个。JVM规范要求进入这里的String实例叫“被驻留的interned string”，各个JVM可以有不同的实现，HotSpot是设置了一个哈希表StringTable来引用堆中的字符串实例，被引用就是被驻留。 详细分析 12int x = 10;String y = \"hello\"; 首先，10和&quot;hello&quot;会在经过javac（或者其他编译器）编译过后变为class文件中constant_pool table的内容。当程序运行时，也就是说JVM运行时，每个class的constant_pool table中的内容会被加载到JVM内存中的方法区中各自class的Runtime Constant Pool。 一个没有被String Pool包含的Runtime Constant Pool中的字符串（这里是”hello”）会被加入到String Pool中（HosSpot使用hashtable引用方式），步骤如下： 在Java Heap中根据”hello”字面量create一个字符串对象。 将字面量”hello”与字符串对象的引用在hashtable中关联起来，键 - 值 形式是：”hello” = 对象的引用地址。 另外来说，当一个新的字符串出现在Runtime Constant Pool中时怎么判断需不需要在Java Heap中创建新对象呢？ 策略是这样： 会先去根据equals来比较Runtime Constant Pool中的这个字符串是否和String Pool中某一个是相等的（也就是找是否已经存在） 如果有那么就不创建，直接使用其引用。 如此，就实现了享元模式，提高的内存利用效率。","link":"/2020/202006051746/"},{"title":"java内存模型","text":"java虚拟机执行java程序时，会把他管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。 一、Java内存区域1.1 运行时数据区域程序计数器 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。 在虚拟机的概念模型里（仅是概念模型，不同虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时就是通过改变该计数器的值来取下一条需要执行的字节码。 由于java虚拟机多线程是通过线程轮流切换分配处理器来实现，任何时刻一个处理器只会运行一个线程，所以，为了线程切换后能恢复到正确执行位置，每个线程都需要一个程序计数器，各线程计数器互不影响。 这类内存区域被称为“线程私有”内存。 若线程执行java方法，则计数器记录虚拟机字节码地址。如果执行native方法，则计数器为空（undefined）。 该区域是唯一一个没规定任何OutOfMemoryError的方法。 java虚拟机栈 java虚拟机栈也是线程私有的，其生命周期与线程相同。 虚拟机栈描述了java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于保存局部变量表、操作数栈、动态链接、方法出口等信息。 每个方法从调用至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。 局部变量表所需内存空间在编译期间完成分配。当进入一个方法时，其需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。 Java虚拟机栈上规定了两种异常状况： 线程请求的栈深度大于虚拟机运行的深度，抛出StackOverflowError异常 虚拟机栈一般可以动态扩展，如果扩展时无法申请到足够内存，抛出OutOfMemoryError异常。 本地方法栈 发挥作用与 虚拟机栈类似，但本地方法栈是为虚拟机使用的native方法服务。 本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 java堆 java堆是java虚拟机所管理的内存中最大的一块。 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。java堆是垃圾收集管理的主要区域。 根据java虚拟机规范，java堆可以处于物理上不连续的内存空间中，只要逻辑上实连续的即可。在实现时，即可实现成固定大小，也可是可扩展的。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。 方法区 方法区与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池 运行时常量池是方法区的一部分。 Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。 java虚拟机对Class文件的每一部分的格式有严格规定，符合规范才能被虚拟机认可、装载和执行，但对运行时常量池，规范没有做任何细节的要求。 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，java语言并不要求常量一定只有编译期能生成（加载Class文件中常量池的内容），运行时也可将新常量放入池中。（例如String类的intern（）方法）。 常量池无法申请到内存时抛出OutOfMemoryError异常。 直接内存 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 但该部分内存也被频繁使用，也可能导致OutOfMemoryError异常。 二、虚拟机在java堆中对象分配、布局和访问过程以HotSpot虚拟机为例。 2.1 对象创建语言层面，创建对象使用new关键字，在虚拟机中，创建对象（普通对象，不包括数组和Class对象）的过程如下： 虚拟机遇到一个new指令，首先将去检查该指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。 类加载检查通过后，接下来虚拟机将为新对象分配内存。内存所需内存大小在类加载完成后便可完全确定。为对象分配空间的任务等同于把一块确定大小的内存从内存中划分出来。 假设java堆内存绝对规整，采用“指针碰撞”方式分配内存。（移动使用/空闲内存分界点指示器指针分配内存） 假设java堆内存不规整，采用“空闲列表”方式分配内存。（使用列表记录使用/空闲内存情况，分配内存后更新列表） 一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使仅修个一个指针指向的位置，并发情况下也不是线程安全的。有两种分配方案： 对分配内存空间的动作进行同步处理。（虚拟机实际使用CAS+失败重试保证操作的原子性） 把内存分配的动作按线程划分在不同的空间中进行，即每个线程在java堆中预先分配一个小块内存，称为本地线程分配缓冲（TLAB）。 内存分配完后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），该操作保证了对象编码时不赋初值也可直接使用。 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄信息等。这些信息放在对象的对象头中。 这时，从虚拟机视角看，对象已产生。但从java程序视角看，对象创建刚开始，方法没有执行，所有字段都还是零值。执行new之后，接着会执行方法，把对象按照程序员的语言进行初始化。 三、对象的内存布局以HotSpot虚拟机为例，对象在内存中存储的布局分为3个区域：对象头、实例数据和对齐填充。 对象头 对象头包括两个部分信息： 第一部分：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等，称为“Mark Word”。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，会根据对象状态复用自己的存储空间。 第二个部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个确定这个对象是哪个类的实例。（并非所有虚拟机都实现这个指针，查找对象元数据信息并不一定要经过对象本身） 实例数据 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 无论是从父类集成还是子类中定义的，都需要记录。 这部分的存储顺序会受虚拟机默认的分配策略参数和字段在java源码中的定义顺序影响。 对齐填充 不是必然存在的，也没有特别含义，仅做占位符。 HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以需要填充对齐。 四、对象的访问定位java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以，对象访问方式取决于虚拟机具体实现。 主流有使用句柄和直接指针两种。 使用句柄访问：java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针访问：reference中存储的直接就是对象地址。 两种方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，而对象被移动时只会改变句柄中的实例数据指针，而reference本身不用修改。 使用直接地址访问的最大好处就是速度更快。","link":"/2019/202005251553/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/201909010101/"},{"title":"vue.js自定义指令介绍与使用","text":"除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有的情况下，你需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 简介注册自定义指令可以采用全局注册也可以在组件中采用局部注册，方法如下： 全局注册指令123456789// 注册一个全局自定义指令 `v-focus`// 功能为页面加载时元素自动获得聚焦Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() }}) 局部注册指令在组件中局部注册时，组件中可以接受一个directives的选项，可以在这个选项中设置自定义指令。 12345678910// 局部注册一个v-focus指令// 组件中接受一个directives的选项directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } }} 使用然后你可以在模板中任何元素上使用新的 v-focus 属性，如下： 1&lt;input v-focus&gt; 钩子函数我们可以选择特定的钩子函数，以此设置指令的作用时机，一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数我们来看一下钩子函数的参数 (即 el，binding，vnode，oldVnode） 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 “1 + 1” arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注： 除了 el之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 例： 这是一个使用了这些属性的自定义钩子样例。 1&lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt; 123456789101112Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') }}) 123456new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' }}) 结果 12345678name:&quot;demo&quot;value:&quot;hello!“expression:&quot;message&quot;argument:&quot;foo&quot;modifiers:{&quot;a&quot;:true,&apos;b&quot;:true]vnodekeys:tag,data,children,text,elm,ns，context,fnContext,fnOptions，fnScopeld,key,componentOptions,componentlnstance，parent,isStatic,isRootlnsert,isComment,isCloned,isOnce，asyncFact01Y,asyncMeta,isAsyncPlaceholder 动态指令参数指令的参数可以是动态的。 例如，在 v-mydirective:[argument]=&quot;value&quot; 中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。 例： 创建一个自定义指令，用来通过固定布局将元素固定在页面上。 1234&lt;div id=\"dynamicexample\"&gt; &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt; &lt;p v-pin:[direction]=\"200\"&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt; 123456789101112131415Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' }})new Vue({ el: '#dynamicexample', data: function () { return { direction: 'left' } }}) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 1&lt;div v-demo=\"{ color: 'white', text: 'hello!' }\"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) { console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"})","link":"/2019/201911010101/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"ES6","slug":"前端/ES6","link":"/categories/%E5%89%8D%E7%AB%AF/ES6/"},{"name":"jdk源码","slug":"java/jdk源码","link":"/categories/java/jdk%E6%BA%90%E7%A0%81/"},{"name":"虚拟机","slug":"java/虚拟机","link":"/categories/java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"vue","slug":"前端/vue","link":"/categories/%E5%89%8D%E7%AB%AF/vue/"}]}