{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"[1] ES6 let与const用法总结","text":"本文主要记录ES6与旧规范相比存在的不同。相较于ES5，ES6新增了let命令和const命令来声明变量与常量，用于代替原本的var命令，以此避免var所带来的弊端。 let命令es6新增了let命令，用于声明变量，声明的变量只在let命令所在的代码块内有效。 不存在变量提升 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。 不允许重复声明 块级作用域es5只用全局作用作用域和函数作用域，没有块级作用域，这带来了很多不合理的场景。 const命令基本用法 const声明一个只读的常量，一旦声明，常量的值就不能改变。同时也意味着，const一旦声明变量，就必须立即初始化，不能等到以后赋值。 const的作用域与let相同，也不提升，同样存在暂时性死区。 本质 const实际保证的并不是变量的值不能改动，而是变量指向的那个内存地址的数据不得改动。 顶层对象的属性顶层对象 在浏览器环境指window对象，在node环境指global对象，顶层对象的属性与全局变量是等价的。 从es6开始，全局变量将逐步与顶层对象的属性脱钩。","link":"/2019/ck54we29s0000zstracn0124r/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/ck54we29z0001zstr9q89680u/"},{"title":"vue.js自定义指令介绍与使用","text":"除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有的情况下，你需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 简介注册自定义指令可以采用全局注册也可以在组件中采用局部注册，方法如下： 全局注册指令123456789// 注册一个全局自定义指令 `v-focus`// 功能为页面加载时元素自动获得聚焦Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() }}) 局部注册指令在组件中局部注册时，组件中可以接受一个directives的选项，可以在这个选项中设置自定义指令。 12345678910// 局部注册一个v-focus指令// 组件中接受一个directives的选项directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } }} 使用然后你可以在模板中任何元素上使用新的 v-focus 属性，如下： 1&lt;input v-focus&gt; 钩子函数我们可以选择特定的钩子函数，以此设置指令的作用时机，一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数我们来看一下钩子函数的参数 (即 el，binding，vnode，oldVnode） 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 “1 + 1” arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注： 除了 el之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 例： 这是一个使用了这些属性的自定义钩子样例。 1&lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt; 123456789101112Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') }}) 123456new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' }}) 结果 12345678name:&quot;demo&quot;value:&quot;hello!“expression:&quot;message&quot;argument:&quot;foo&quot;modifiers:{&quot;a&quot;:true,&apos;b&quot;:true]vnodekeys:tag,data,children,text,elm,ns，context,fnContext,fnOptions，fnScopeld,key,componentOptions,componentlnstance，parent,isStatic,isRootlnsert,isComment,isCloned,isOnce，asyncFact01Y,asyncMeta,isAsyncPlaceholder 动态指令参数指令的参数可以是动态的。 例如，在 v-mydirective:[argument]=&quot;value&quot; 中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。 例： 创建一个自定义指令，用来通过固定布局将元素固定在页面上。 1234&lt;div id=\"dynamicexample\"&gt; &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt; &lt;p v-pin:[direction]=\"200\"&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt; 123456789101112131415Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' }})new Vue({ el: '#dynamicexample', data: function () { return { direction: 'left' } }}) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 1&lt;div v-demo=\"{ color: 'white', text: 'hello!' }\"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) { console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"})","link":"/2019/ck54we2at0008zstr7nkq4v1h/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"前端/ES6","link":"/categories/%E5%89%8D%E7%AB%AF/ES6/"},{"name":"vue","slug":"前端/vue","link":"/categories/%E5%89%8D%E7%AB%AF/vue/"}]}