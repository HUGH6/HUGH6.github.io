{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"JDK源码 Object类","text":"Obejct类是所有其他类的父类，所有的对象，包括数组对象，都实现了该类的方法，它提供了以下11个方法： public final native Class&lt;?&gt; getClass() public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException protected void finalize() throws Throwable { } 一、源码分析1.1 getClass()native方法，final修饰，子类不可重写。 函数功能： 返回当前运行时对象的Class对象（注意：是运行时，例如，下面代码中n是Number类型的实例，但java中数值默认是Integer类型的，所以getClass返回的是Integer）。 1234\"str\".getClass() // class java.lang.String\"str\".getClass == String.class // trueNumber n = 0;Class&lt;? extends Number&gt; c = n.getClass(); // class java.lang.Integer 1.2 hashCode()native方法，返回对象的哈希码，主要用于HashMap等数据结构。 哈希码的通用阅读如下： 在java程序执行过程中，在一个对象没有被改变的前提下，无论这个对象被调用多少次，hashCode方法都会返回相同的整数值。 对象的哈希码没有必要在不同的程序中保持相同的值。 如果2个对象使用equals方法进行比较并且相同的话，那么这2个对象的hashCode方法的值也必须相等。 如果根据equals方法，得到两个对象不相等，那么这2个对象的hashCode值不需要必须不相同。但是，不相等的对象的hashCode值不同的话可以提高哈希表的性能。 注意：如果2个对象的equals方法相等，那么他们的hashCode值也必须相等，反之，如果2个对象hashCode值相等，但是equals不相等，这样会影响性能，所以还是建议2个方法都一起重写。 1.3 equals()比较两个对象是否相等。Object类的默认实现是比较2个对象的内存地址是否相等： 123public boolean equals(Object obj) { return (this == obj);} 注意：如果重写了equals方法，通常有必要重写hashCode方法，这点已经在hashCode方法中说明了。 1.4 clone()native方法，创建并返回当前对象的一份拷贝。 一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 也为true。 由于Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。 1.5 toString()Object对象的默认实现，即输出类的名字@实例的哈希码的16进制： 123public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode());} 1.6 notify()native方法，final修饰，不允许子类重写。 唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果所有的线程都在此对象上等待，那么只会选择一个线程，选择是任意性的。 直到当前线程放弃对象上的锁之后，被唤醒的线程才可以继续处理。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。 notify方法只能被作为此对象监视器的所有者的线程来调用。一个线程要想成为对象监视器的所有者，可以使用以下3种方法： 执行对象的同步实例方法 使用synchronized内置锁 对于Class类型的对象，执行同步静态方法 一次只能有一个线程拥有对象的监视器。 如果当前线程不是此对象监视器的所有者的话会抛出IllegalMonitorStateException异常 注意点： 因为notify只能在拥有对象监视器的所有者线程中调用，否则会抛出IllegalMonitorStateException异常 1.7 notifyAll()跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 同样，如果当前线程不是对象监视器的所有者，那么调用notifyAll同样会发生IllegalMonitorStateException异常。 1.8 wait(long timeout) throws InterruptedExceptionnative方法，final修饰，子类不可重写。 wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。 跟notify和notifyAll方法一样，当前线程必须是此对象的监视器所有者，否则还是会发生IllegalMonitorStateException异常。 wait方法会让当前线程(我们先叫做线程T)将其自身放置在对象的等待集中，并且放弃该对象上的所有同步要求。出于线程调度目的，线程T是不可用并处于休眠状态，直到发生以下四件事中的任意一件： 其他某个线程调用此对象的notify方法，并且线程T碰巧被任选为被唤醒的线程 其他某个线程调用此对象的notifyAll方法 其他某个线程调用Thread.interrupt方法中断线程T 时间到了参数设置的超时时间。如果timeout参数为0，则不会超时，会一直进行等待 所以可以理解wait方法相当于放弃了当前线程对对象监视器的所有者(也就是说释放了对象的锁)。之后，线程T会被等待集中被移除，并且重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用wait方法时的情况。然后，线程T从wait方法的调用中返回。所以，从wait方法返回时，该对象和线程T的同步状态与调用wait方法时的情况完全相同。 1.9 wait(long timeout, int nanos) throws InterruptedException同wait(long timeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。 1.10 wait() throws InterruptedException该方法一直等待，没有超时时间这个概念。 1.11 finalize()finalize方法是一个protected方法，Object类的默认实现是不进行任何操作。 该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。","link":"/2020/202006051524/"},{"title":"[1] ES6 let与const用法总结","text":"本文主要记录ES6与旧规范相比存在的不同。相较于ES5，ES6新增了let命令和const命令来声明变量与常量，用于代替原本的var命令，以此避免var所带来的弊端。 let命令es6新增了let命令，用于声明变量，声明的变量只在let命令所在的代码块内有效。 不存在变量提升 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。 不允许重复声明 块级作用域es5只用全局作用作用域和函数作用域，没有块级作用域，这带来了很多不合理的场景。 const命令基本用法 const声明一个只读的常量，一旦声明，常量的值就不能改变。同时也意味着，const一旦声明变量，就必须立即初始化，不能等到以后赋值。 const的作用域与let相同，也不提升，同样存在暂时性死区。 本质 const实际保证的并不是变量的值不能改动，而是变量指向的那个内存地址的数据不得改动。 顶层对象的属性顶层对象 在浏览器环境指window对象，在node环境指global对象，顶层对象的属性与全局变量是等价的。 从es6开始，全局变量将逐步与顶层对象的属性脱钩。","link":"/2019/201910010101/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/201909010101/"},{"title":"java内存模型","text":"java虚拟机执行java程序时，会把他管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。 一、Java内存区域1.1 运行时数据区域程序计数器 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。 在虚拟机的概念模型里（仅是概念模型，不同虚拟机可能会通过一些更高效的方式实现），字节码解释器工作时就是通过改变该计数器的值来取下一条需要执行的字节码。 由于java虚拟机多线程是通过线程轮流切换分配处理器来实现，任何时刻一个处理器只会运行一个线程，所以，为了线程切换后能恢复到正确执行位置，每个线程都需要一个程序计数器，各线程计数器互不影响。 这类内存区域被称为“线程私有”内存。 若线程执行java方法，则计数器记录虚拟机字节码地址。如果执行native方法，则计数器为空（undefined）。 该区域是唯一一个没规定任何OutOfMemoryError的方法。 java虚拟机栈 java虚拟机栈也是线程私有的，其生命周期与线程相同。 虚拟机栈描述了java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于保存局部变量表、操作数栈、动态链接、方法出口等信息。 每个方法从调用至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。 局部变量表所需内存空间在编译期间完成分配。当进入一个方法时，其需要在帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。 Java虚拟机栈上规定了两种异常状况： 线程请求的栈深度大于虚拟机运行的深度，抛出StackOverflowError异常 虚拟机栈一般可以动态扩展，如果扩展时无法申请到足够内存，抛出OutOfMemoryError异常。 本地方法栈 发挥作用与 虚拟机栈类似，但本地方法栈是为虚拟机使用的native方法服务。 本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 java堆 java堆是java虚拟机所管理的内存中最大的一块。 Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。java堆是垃圾收集管理的主要区域。 根据java虚拟机规范，java堆可以处于物理上不连续的内存空间中，只要逻辑上实连续的即可。在实现时，即可实现成固定大小，也可是可扩展的。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。 方法区 方法区与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池 运行时常量池是方法区的一部分。 Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。 java虚拟机对Class文件的每一部分的格式有严格规定，符合规范才能被虚拟机认可、装载和执行，但对运行时常量池，规范没有做任何细节的要求。 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，java语言并不要求常量一定只有编译期能生成（加载Class文件中常量池的内容），运行时也可将新常量放入池中。（例如String类的intern（）方法）。 常量池无法申请到内存时抛出OutOfMemoryError异常。 直接内存 直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 但该部分内存也被频繁使用，也可能导致OutOfMemoryError异常。 二、虚拟机在java堆中对象分配、布局和访问过程以HotSpot虚拟机为例。 2.1 对象创建语言层面，创建对象使用new关键字，在虚拟机中，创建对象（普通对象，不包括数组和Class对象）的过程如下： 虚拟机遇到一个new指令，首先将去检查该指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。 类加载检查通过后，接下来虚拟机将为新对象分配内存。内存所需内存大小在类加载完成后便可完全确定。为对象分配空间的任务等同于把一块确定大小的内存从内存中划分出来。 假设java堆内存绝对规整，采用“指针碰撞”方式分配内存。（移动使用/空闲内存分界点指示器指针分配内存） 假设java堆内存不规整，采用“空闲列表”方式分配内存。（使用列表记录使用/空闲内存情况，分配内存后更新列表） 一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使仅修个一个指针指向的位置，并发情况下也不是线程安全的。有两种分配方案： 对分配内存空间的动作进行同步处理。（虚拟机实际使用CAS+失败重试保证操作的原子性） 把内存分配的动作按线程划分在不同的空间中进行，即每个线程在java堆中预先分配一个小块内存，称为本地线程分配缓冲（TLAB）。 内存分配完后，虚拟机需要将分配的内存空间初始化为零值（不包括对象头），该操作保证了对象编码时不赋初值也可直接使用。 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄信息等。这些信息放在对象的对象头中。 这时，从虚拟机视角看，对象已产生。但从java程序视角看，对象创建刚开始，方法没有执行，所有字段都还是零值。执行new之后，接着会执行方法，把对象按照程序员的语言进行初始化。 三、对象的内存布局以HotSpot虚拟机为例，对象在内存中存储的布局分为3个区域：对象头、实例数据和对齐填充。 对象头 对象头包括两个部分信息： 第一部分：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等，称为“Mark Word”。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，会根据对象状态复用自己的存储空间。 第二个部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个确定这个对象是哪个类的实例。（并非所有虚拟机都实现这个指针，查找对象元数据信息并不一定要经过对象本身） 实例数据 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 无论是从父类集成还是子类中定义的，都需要记录。 这部分的存储顺序会受虚拟机默认的分配策略参数和字段在java源码中的定义顺序影响。 对齐填充 不是必然存在的，也没有特别含义，仅做占位符。 HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以需要填充对齐。 四、对象的访问定位java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以，对象访问方式取决于虚拟机具体实现。 主流有使用句柄和直接指针两种。 使用句柄访问：java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针访问：reference中存储的直接就是对象地址。 两种方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，而对象被移动时只会改变句柄中的实例数据指针，而reference本身不用修改。 使用直接地址访问的最大好处就是速度更快。","link":"/2019/202005251553/"},{"title":"vue.js自定义指令介绍与使用","text":"除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有的情况下，你需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 简介注册自定义指令可以采用全局注册也可以在组件中采用局部注册，方法如下： 全局注册指令123456789// 注册一个全局自定义指令 `v-focus`// 功能为页面加载时元素自动获得聚焦Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() }}) 局部注册指令在组件中局部注册时，组件中可以接受一个directives的选项，可以在这个选项中设置自定义指令。 12345678910// 局部注册一个v-focus指令// 组件中接受一个directives的选项directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } }} 使用然后你可以在模板中任何元素上使用新的 v-focus 属性，如下： 1&lt;input v-focus&gt; 钩子函数我们可以选择特定的钩子函数，以此设置指令的作用时机，一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数我们来看一下钩子函数的参数 (即 el，binding，vnode，oldVnode） 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 “1 + 1” arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注： 除了 el之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 例： 这是一个使用了这些属性的自定义钩子样例。 1&lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt; 123456789101112Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') }}) 123456new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' }}) 结果 12345678name:&quot;demo&quot;value:&quot;hello!“expression:&quot;message&quot;argument:&quot;foo&quot;modifiers:{&quot;a&quot;:true,&apos;b&quot;:true]vnodekeys:tag,data,children,text,elm,ns，context,fnContext,fnOptions，fnScopeld,key,componentOptions,componentlnstance，parent,isStatic,isRootlnsert,isComment,isCloned,isOnce，asyncFact01Y,asyncMeta,isAsyncPlaceholder 动态指令参数指令的参数可以是动态的。 例如，在 v-mydirective:[argument]=&quot;value&quot; 中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。 例： 创建一个自定义指令，用来通过固定布局将元素固定在页面上。 1234&lt;div id=\"dynamicexample\"&gt; &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt; &lt;p v-pin:[direction]=\"200\"&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt; 123456789101112131415Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' }})new Vue({ el: '#dynamicexample', data: function () { return { direction: 'left' } }}) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 1&lt;div v-demo=\"{ color: 'white', text: 'hello!' }\"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) { console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"})","link":"/2019/201911010101/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"虚拟机","slug":"java/虚拟机","link":"/categories/java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"jdk源码","slug":"java/jdk源码","link":"/categories/java/jdk%E6%BA%90%E7%A0%81/"},{"name":"ES6","slug":"前端/ES6","link":"/categories/%E5%89%8D%E7%AB%AF/ES6/"},{"name":"vue","slug":"前端/vue","link":"/categories/%E5%89%8D%E7%AB%AF/vue/"}]}